---
title: "Verifying sample relationships using DNA Methylation data en Whole Genome Sequencing data"
package: "omicsPrint"
abstract: 
  "Here we will show how you could verify sample relationships on
  publicly available DNA methylation data and whole genome sequencing
  data. We use the beta-value matrix extracted from GEO (GSE39672) and
  collect 1000G genotypes for partially overlapping samples from
  [IGSR: The International Genome Sample Resource](http://www.internationalgenome.org/data/)."
author:
- name: "Maarten van Iterson"
  affiliation:
  - "Department of Medical Statistics and Bioinformatics, Section Moleculair Epidemiology, Leiden University Medical Center"
  email: mviterson@gmail.com
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document2:
    toc: true
    toc_float:
      collapsed: false
vignette: >
  %\VignetteIndexEntry{Verifying sample relationships using DNA Methylation data en Whole Genome Sequencing data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: omicsPrint.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=FALSE, cache=TRUE)
suppressPackageStartupMessages({
    library(omicsPrint)
    library(GEOquery)
    library(GenomicRanges)
    library(FDb.InfiniumMethylation.hg19)
    library(BiocParallel)
})
```

# Methylation Data #

First we extract the data from GEO using the
[*GEOquery*](http://bioconductor.org/packages/GEOquery/)-package and
beta-values are extracted using the `exprs`-function:

```{r, downloaddata}
library(GEOquery)
gset <- getGEO("GSE39672", GSEMatrix=TRUE) 
gset
betas <- exprs(gset[[1]]) 
dim(betas)
```

Sample names can be extract from the `gse`-object using the
`pData`-function:

```{r, extractphenotypes}
population <- gsub("^.* ", "", pData(gset[[1]])$characteristics_ch1)
table(population)
colnames(betas) <- gsub("^.* ", "", pData(gset[[1]])$title)
betas[1:5, 1:5]
```

If we would have had the raw idats we could extract the 65
SNPs. However, experiences show that the 65 SNPs available on the
array are not enough to perform sample verification with high
confidence. Fortunately, several probes on the array contain SNPs
occuring frequently in different populations[@Chen2013; @Zhou2016]. 

We have made the data available from inside of this package package in a 
`GRanges`-object.

Now we make a selection of CpGs probably affected by polymorphic SNPS
in these two populations:

```{r, selectcpgs}
library(omicsPrint)
library(GenomicRanges)
data(hm450.manifest.pop.GoNL)
cpgs <- names(hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.CEU
                                      | mcols(hm450.manifest.pop.GoNL)$MASK.snp5.YRI])
```

Next the beta-values are converted to genotypes using our enhanced
K-means algorithm:

```{r, genotyping}
dnamCalls <- beta2genotype(betas[rownames(betas) %in% cpgs, ])
dim(dnamCalls)
dnamCalls[1:5, 1:5]
```

The DNA methylation based genotype calls can directly supplied to the
allelesharing algorithm to perform the intra-omic sample matching:

```{r, allelesharing}
data <- alleleSharing(dnamCalls)
mismatches <- inferRelations(data)
nrow(data) ##number of pairs
ncol(dnamCalls) ##identical
ncol(dnamCalls)*(ncol(dnamCalls) - 1)/2 ##non-identical
ncol(dnamCalls)*(ncol(dnamCalls) + 1)/2 ##total
```

There are no unknown relations in the data, verifying @Moen2013, as
all samples should be unrelated.

> NOTE: the number just represent the number of diagonal elements,
> off-diagonal (upper or lower) and diagonal + off-diagonal
> (upper/lower) of the square matrix with sample identifiers.

# Genotype Data #


Since the sample used in this study (GSE39672) are overlapping with
the HapMap and 1000G samples we can extract the whole genome
sequencing derived genotypes.

Here is a helper-function for the extraction of genotypes from the
1000G per chromosome vcf-files using the
[*VariantAnnotation*](https://bioconductor.org/packages/VariantAnnotation)-package.
Furthermore, we use the `genotypeToSnpMatrix`-function to convert
genotypes that we directly can use in the allelesharing algorithm.

```{r, genotypeextractor}
getSnpMatrix <- function(chr, samples = NULL, which) {
    require(VariantAnnotation)
    require(Rsamtools)
    message("Extracting SNPs for chromosome: ", chr)
    
    vcfFile <- paste0("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr", chr,
                      ".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz")

    indexFile <-  paste0("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr", chr,
                         ".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz.tbi")

    tabFile <- TabixFile(vcfFile, indexFile)

    if(is.null(samples))
        param <- ScanVcfParam(geno = "GT",
                              which = which[seqnames(which) == chr])
    else
        param <- ScanVcfParam(geno = "GT",
                              samples = samples,
                              which = which[seqnames(which) == chr])

    message("Reading vcf ...")
    vcf <- readVcf(tabFile, "hg19", param = param)
    
    message("Transform to SnpMatrix ...")
    m <- genotypeToSnpMatrix(vcf)$genotypes

    ##debugging
    ##message(str(m))
    
    m <- t(matrix(as.numeric(m),
                  nrow = nrow(m),
                  ncol = ncol(m),
                  dimnames = dimnames(m)))
    
    rownames(m) <- paste(seqnames(vcf@rowRanges),
                         start(vcf@rowRanges), sep=":")
    m
}
```

Extract genotypes from the vcf-files that are occuring in all
populations. Optionally you could extract only those that overlap with
the DNA methylation data by suppling the `sample`-names. Now we use a
`GenomicRange`-object to specify specifically which SNPs we would like
to extract.

This extraction can take some time. We run this on a multi-core
machine using 6 cores in combination with the
[*BiocParallel*](https://bioconductor.org/packages/BiocParallel)-package.


```{r, extractgenotypes}
data(hm450.manifest.pop.GoNL)
gr <- hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.CEU
                                      | mcols(hm450.manifest.pop.GoNL)$MASK.snp5.YRI]

mcols(gr) <- NULL
seqlevels(gr) <- mapSeqlevels(seqlevels(gr), "NCBI")
gr
##check one
##dnaCalls <- getSnpMatrix(22, samples = samples, which=gr)
##dim(dnaCalls)
library(BiocParallel)
register(MulticoreParam(6))
dnaCalls <- bplapply(1:22, getSnpMatrix, samples = colnames(dnamCalls), which=gr)
##dnaCalls <- bplapply(1:6, getSnpMatrix, samples = NULL, which=gr)
dnaCalls <- do.call('rbind', dnaCalls)
dim(dnaCalls)
dnaCalls[1:5, 1:5]
```

To select the most informative SNPs, e.g., we can calculate the minor
allel frequenties and retain those above a certain threshold, i.e.,
0.01 and drop uninformative ones.

```{r, filtering}
maf <- apply(dnaCalls, 1, function(x) min(table(x)/length(x)))
hist(maf)
dnaCalls <- dnaCalls[maf > 0.01 & maf < 1,]
dim(dnaCalls)
```

Now we can run the allelesharing algorithm on the genotype data:

```{r, allelesharing1}
library(omicsPrint)
data <- alleleSharing(dnaCalls)
mismatches <- inferRelations(data)
mismatches
nrow(data) ##number of pairs
ncol(dnaCalls) ##identical
ncol(dnaCalls)*(ncol(dnaCalls) - 1)/2 ##non-identical
ncol(dnaCalls)*(ncol(dnaCalls) + 1)/2 ##total
```

# Genotype and Methylation Data #

To be able to run the allele sharing algorithm between the DNA
methylation and genotype data there should be an overlapping set of
SNPs.

Here we map probe identifiers to `chromosome:position`, like the
genotype data using information for the array provider available from
the
[*FDb.InfiniumMethylation.hg19*](https://bioconductor.org/packages/FDb.InfiniumMethylation.hg19)-package,
and rename to probes.

```{r, renamecpgs}
library(FDb.InfiniumMethylation.hg19)
rngs <- getPlatform(platform='HM450', genome='hg19')
seqlevels(rngs) <- mapSeqlevels(seqlevels(rngs), "NCBI")

map <- names(rngs)
names(map) <- paste(seqnames(rngs),
                    mcols(rngs)$probeTarget, sep=":")
mid <- match(map, rownames(betas))
rownames(betas)[mid] <- names(map)

library(omicsPrint)
dnamCalls <- beta2genotype(betas[rownames(betas) %in% rownames(dnaCalls),])
dim(dnamCalls)
dim(dnaCalls)

data <- alleleSharing(dnamCalls, dnaCalls, phasing=TRUE)
mismatches <- inferRelations(data)
mismatches

##ncol(dnamCalls) * ncol(dnaCalls) ## now the matrix is rectangular

require(readxl)
file <- tempfile(fileext=".ped")
download.file("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_g1k.ped", destfile=file)

ped <- read.table(file, header=TRUE, sep="\t")
subset(ped, Individual.ID == "NA19129")
```

There are 103 overlapping samples between DNA and DNAm. Three pairs of
DNA-DNAm seems not properly matching. I suspect bad quality of DNAm or
DNA! And one unrelated is parent offspring relation, for example, this
is verified by information from the pedigree file. Using imputed DNA
genotypes will increase the number of SNPs overlapping with the DNA
methylation data. Further, note that no quality control was performed
on the DNAm data (we only have access to the beta-values).

# Detect mislabelled samples #

In order to show how mislabelled samples can be detected some
mislabeling is artificially introduced, i.e. a known `identical`
relation is removed and `unrelated` pair is set to identical.

```{r, allelesharing2}
set.seed(12345)
relations <- expand.grid(idx = colnames(dnamCalls), idy = colnames(dnaCalls))
relations$relation_type <- "unrelated"
relations$relation_type[as.character(relations$idx) == as.character(relations$idy)] <- "identical"

id <- sample(which(relations$relation_type == "identical"), 10)
relations[id,]
relations$relation_type[id] <- "unrelated"

id <- sample(which(relations$relation_type == "unrelated"), 10)
relations[id,]
relations$relation_type[id] <- "identical"
relations <- relations[relations$relation_type == "identical",]

library(omicsPrint)
data <- alleleSharing(dnamCalls, dnaCalls, relations=relations, phasing=TRUE)
mismatches <- inferRelations(data)
mismatches
```

These mislabel samples (pairs) are automatically detected.

# Customized plots #

Here we show some examples for creating customized plots of the mean
and variance of IBS:


```{r, customized, eval=FALSE}
data <- alleleSharing(dnaCalls)
plotdata <- inferRelations(data, plot.it=FALSE)

ped <- read.table("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_g1k.ped", header=TRUE, sep="\t")

plotdata$population.x <- plotdata$population.y <- "unknown"
mid <- match(plotdata$colnames.x, ped$Individual.ID)
plotdata$population.x <- ped$Population[mid]
mid <- match(plotdata$colnames.y, ped$Individual.ID)
plotdata$population.y <- ped$Population[mid]

colors <- factor(paste(plotdata$population.x, plotdata$population.y, sep="-"))
levels(colors)[grepl("NA", levels(colors))] <- "unknown"

levels(colors)[2] <- levels(colors)[3]
labels <- colors
table(colors)
levels(colors) <- c("red", "blue", "orange")

with(plotdata, {
    plot(mean, var, pch=18, col=adjustcolor(colors, alpha.f = 0.3),
         xlab="mean (IBS)", ylab="variance (IBS)")
    points(2, 0, pch=18, col="black")
    legend("topright", levels(labels), col=levels(colors), pch=18, bty="n")
     })

## with(plotdata, {
##     id <- which(predicted != relation)
    
##     levels(relation) <- c("black", "red")

##     plot(mean, var, pch=18, col=adjustcolor(relation, alpha.f = 0.3),
##          xlab="mean (IBS)", ylab="variance (IBS)")
##     points(mean[id], var[id], pch=18, col=relation[id])    
##      })

```


# SessionInfo #

```{r, sessioninfo}
sessionInfo()
```

# Reference #
