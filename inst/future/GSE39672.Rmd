---
title: "Verifying sample relationships using DNA Methylation data en Whole Genome Sequencing data"
package: "omicsPrint"
abstract: 
  Here we will show how you could verify sample relationships on
  publicly available DNA methylation data and whole genome sequencing
  data. We use the beta-value matrix extracted from GEO (GSE39672) and
  collect 1000G genotypes for partially overlapping samples from
  [IGSR: The International Genome Sample Resource](http://www.internationalgenome.org/data/).
author:
- name: "Maarten van Iterson"
  affiliation:
  - "Department of Medical Statistics and Bioinformatics, Section Moleculair Epidemiology, Leiden University Medical Center"
  email: mviterson@gmail.com
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document2:
    toc: true
    toc_float:
      collapsed: false
  pdf_document:
    toc: true
    toc_depth: 2	
  github_document:
    toc: true
    toc_depth: 2	
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: omicsPrint.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=FALSE, cache=TRUE)
suppressPackageStartupMessages({
    library(omicsPrint)
    library(GEOquery)
    library(DNAmArray) #see https://github.com/molepi/DNAmArray
})
```

# Methylation Data #

First we extract the data from GEO using the
[*GEOquery*](http://bioconductor.org/packages/GEOquery/)-package and
beta-values are extracted using the `exprs`-function:

```{r, downloaddata}
library(GEOquery)
gset <- getGEO("GSE39672", GSEMatrix=TRUE) 
gset
betas <- exprs(gset[[1]]) 
dim(betas)
```

Sample names can be extract from the `gse`-object using the
`pData`-function:

```{r, extractphenotypes}
population <- gsub("^.* ", "", pData(gset[[1]])$characteristics_ch1)
table(population)
colnames(betas) <- gsub("^.* ", "", pData(gset[[1]])$title)
betas[1:5, 1:5]
```

If we would have had the raw idats we could extract the 65
SNPs. However, experiences show that the 65 SNPs available on the
array are not enough to perform sample verification with high
confidence. Fortunately, several probes on the array contain SNPs
occuring frequently in different populations[@Chen2013; @Zhou2016]. 

We have made the data available from the package
[*DNAmArray*](https://github.com/molepi/omicsPrint).

Now we make a selection of CpGs probably affected by polymorphic SNPS
in these two populations:

```{r, selectcpgs}
library(DNAmArray)
data(hm450.manifest.pop.GoNL)
cpgs <- names(hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.CEU
                                      | mcols(hm450.manifest.pop.GoNL)$MASK.snp5.YRI])
```

Next the beta-values are converted to genotypes using our enhanced
K-means algorithm:

```{r, genotyping}
library(omicsPrint)
dnamCalls <- beta2genotype(betas[rownames(betas) %in% cpgs, ])
dim(dnamCalls)
dnamCalls[1:5, 1:5]
```

The DNA methylation based genotype calls can directly supplied to the
allelesharing algorithm to perform the intra-omic sample matching:

```{r, allelesharing}
data <- alleleSharing(dnamCalls)
mismatches <- inferRelations(data)
```

There are no unknown relations in the data, verifying @Moen2013, as
all samples should be unrelated.


# Genotype Data #


Since the sample used in this study (GSE39672) are overlapping with
the HapMap and 1000G samples we can extract the whole genome
sequencing derived genotypes.

Here is a helper-function for the extraction of genotypes from the
1000G per chromosome vcf-files using the
[*VariantAnnotation*](https://bioconductor.org/packages/VariantAnnotation)-package.
Furthermore, we use the `genotypeToSnpMatrix`-function to convert
genotypes that we directly can use in the allelesharing algorithm.

```{r, genotypeextractor}
getSnpMatrix <- function(chr, samples = NULL, which) {
    require(VariantAnnotation)

    message("Extracting SNPs for chromosome: ", chr)
    
    vcfFile <- paste0("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr", chr,
                      ".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz")

    indexFile <-  paste0("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr", chr,
                         ".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz.tbi")

    tabFile <- TabixFile(vcfFile, indexFile)

    if(is.null(samples))
        param <- ScanVcfParam(geno = "GT",
                              which = which[seqnames(which) == chr])
    else
        param <- ScanVcfParam(geno = "GT",
                              samples = samples,
                              which = which[seqnames(which) == chr])

    message("Reading vcf ...")
    vcf <- readVcf(tabFile, "hg19", param = param)
    
    message("Transform to SnpMatrix ...")
    m <- genotypeToSnpMatrix(vcf)$genotypes

    ##debugging
    ##message(str(m))
    
    m <- t(matrix(as.numeric(m),
                  nrow = nrow(m),
                  ncol = ncol(m),
                  dimnames = dimnames(m)))
    
    rownames(m) <- paste(seqnames(vcf@rowRanges),
                         start(vcf@rowRanges), sep=":")
    m
}
```

Extract genotypes from the vcf-files that are occuring in all
populations. Optionally you could extract only those that overlap with
the DNA methylation data by suppling the `sample`-names. Now we use a
`GenomicRange`-object to specify specifically which SNPs we would like
to extract.

This extraction can take some time. We run this on a multi-core
machine using 22 cores in combination with the
[*BiocParallel*](https://bioconductor.org/packages/BiocParallel)-package.


```{r, extractgenotypes}
library(DNAmArray)
data(hm450.manifest.pop.GoNL)
gr <- hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.CEU
                                      | mcols(hm450.manifest.pop.GoNL)$MASK.snp5.YRI]

mcols(gr) <- NULL
seqlevels(gr) <- mapSeqlevels(seqlevels(gr), "NCBI")
gr
##check one
##dnaCalls <- getSnpMatrix(22, samples = samples, which=gr)
##dim(dnaCalls)
library(BiocParallel)
register(MulticoreParam(22))
##dnaCalls <- bplapply(1:22, getSnpMatrix, samples = colnames(dnamCalls), which=gr)
dnaCalls <- bplapply(1:22, getSnpMatrix, samples = NULL, which=gr)
dnaCalls <- do.call('rbind', dnaCalls)
dim(dnaCalls)
dnaCalls[1:5, 1:5]
```

To select the most informative SNPs, e.g., we can calculate the minor
allel frequenties and retain those above a certain threshold, i.e.,
0.01 and drop uninformative ones.

```{r, filtering}
maf <- apply(dnaCalls, 1, function(x) min(table(x)/length(x)))
hist(maf)
dnaCalls <- dnaCalls[maf > 0.01 & maf < 1,]
dim(dnaCalls)
```

Now we can run the allelesharing algorithm on the genotype data:

```{r, allelesharing1}
library(omicsPrint)
data <- alleleSharing(dnaCalls)
mismatches <- inferRelations(data)
mismatches
```

A few possibly family relations seems to appear around mean IBS of 1.8
and variance 0.15. 

# Genotype and Methylation Data #

To be able to run the allele sharing algorithm between the DNA
methylation and genotype data there should be an overlapping set of
SNPs.

Here we map probe identifiers to `chromosome:position`, like the
genotype data using information for the array provider available from
the
[*FDb.InfiniumMethylation.hg19*](https://bioconductor.org/packages/FDb.InfiniumMethylation.hg19)-package,
and rename to probes.

```{r, renamecpgs}
library(FDb.InfiniumMethylation.hg19)
rngs <- getPlatform(platform='HM450', genome='hg19')
seqlevels(rngs) <- mapSeqlevels(seqlevels(rngs), "NCBI")

map <- names(rngs)
names(map) <- paste(seqnames(rngs),
                    mcols(rngs)$probeTarget, sep=":")
mid <- match(map, rownames(betas))
rownames(betas)[mid] <- names(map)

library(omicsPrint)
dnamCalls <- beta2genotype(betas[rownames(betas) %in% rownames(dnaCalls),])
dim(dnamCalls)
data <- alleleSharing(dnamCalls, dnaCalls, phasing=TRUE)
mismatches <- inferRelations(data)
mismatches

require(readxl)
file <- tempfile(fileext=".ped")
download.file("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_g1k.ped", destfile=file)

ped <- read.table(file, header=TRUE, sep="\t")
subset(ped, Individual.ID == "NA19129")
```

Two pairs of genotype-DNAm seems not properly matching. I suspect bad
quality of DNAm or genotypes! And one unrelated is parent offspring
relation, for example, this is verified by information from the
pedigree file.

# Detect mislabelled samples #

In order to show how mislabelled samples can be detected some
mislabeling is artificially introduced, i.e. a known `identical`
relation is removed and `unrelated` pair is set to identical.

```{r, allelesharing2}
set.seed(12345)
relations <- expand.grid(idx = colnames(dnamCalls), idy = colnames(dnaCalls))
relations$relation_type <- "unrelated"
relations$relation_type[as.character(relations$idx) == as.character(relations$idy)] <- "identical"

id <- sample(which(relations$relation_type == "identical"), 1)
relations[id,]
relations$relation_type[id] <- "unrelated"

id <- sample(which(relations$relation_type == "unrelated"), 1)
relations[id,]
relations$relation_type[id] <- "identical"
relations <- relations[relations$relation_type == "identical",]

library(omicsPrint)
data <- alleleSharing(dnamCalls, dnaCalls, relations=relations, phasing=TRUE)
mismatches <- inferRelations(data)
mismatches
```

These mislabel samples (pairs) are automatically detected.


# SessionInfo #

```{r, sessioninfo}
sessionInfo()
```

# Reference #
