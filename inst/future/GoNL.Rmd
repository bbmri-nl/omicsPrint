---
title: "Sample relationship verification using the GoNL genotype, RNA-sequencing and DNA methylation data"
author: "Maarten van Iterson"
date: "`r Sys.Date()`"
output:
  md_document:
    variant: markdown_github
vignette: >
  %\VignetteIndexEntry{omicsPrint}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: omicsPrint.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, eval=TRUE, cache.lazy = FALSE)

rm(list=ls()) ##clear work space

suppressPackageStartupMessages({ ##to get rid of annoying startup messages (like ours ;)!)
    library(BBMRIomics) #from gitlab   
    library(DNAmArray) #from github
    library(omicsPrint) #from github
      
    library(BiocParallel) ##from bioc
    library(VariantAnnotation)
    library(GenomicFiles)
    library(rtracklayer)
})
```

## Introduction

## Verify sample relations using whole genome sequencing, RNAseq and DNA methylation data

### Extracting Genotype Calls ###

Individual level sequence data and/or variant calls can be requested
via the [GoNL-website](http://www.nlgenome.nl/?page_id=114).

The vcf-files can be easily read using functionality from
`VariantAnnotation` and `GenomicFiles` BioConductor-packages, as
follows:

```{r, extractgenotypecalls, echo=FALSE}
files <- dir(file.path(VM_BASE_DATA, "gonl-snv-release-5.4"),
             pattern = ".vcf.gz$", full.names = TRUE, recursive = TRUE)
names(files) <- sub(".*chr([0-9XY]+).*", "\\1", basename(files))
snps <- import(file.path(VM_BASE_ANALYSIS, "SwapDetection/HighQualPositions.GCRh37.bed"))
##This replaces BBMRIomics `getGenotypes`-function!
stack <- VcfStack(files)
rstack <- RangedVcfStack(stack, snps)
## stack
## rstack
## dim(stack)
## colnames(stack)
## rownames(stack)
## dimnames(stack)
## head(files(stack))
## seqinfo(stack)
## colData(stack)
dnaCalls <- assay(rstack)
```

Here we used the `RangedVcfStack`-class for easy subsetting of a
selection of SNPs.

There is currently no parallel back-end for the
`assay`-function. However, bioc-team promises to implement this in the
near future [](https://support.bioconductor.org/p/96212/).

```{r, preprocessgenotypecalls, echo=FALSE}
dim(dnaCalls)
str(dnaCalls)
names(snps) <- paste(seqnames(snps), start(snps), sep=":")
ovl <- intersect(snps$name, rownames(dnaCalls))
dnaCalls <- dnaCalls[rownames(dnaCalls) %in% ovl, ]
mid <- match(rownames(dnaCalls), snps$name)
head(rownames(dnaCalls))
tail(rownames(dnaCalls))
snps
rownames(dnaCalls) <- names(snps)[mid]
dnaCalls <- dnaCalls + 1
dnaCalls[1:5, 1:5]
```

### Extracting RNAseq Calls ###

SNPs calls were extract from the bam-files and stored in a vcf-file.

```{r, rnaseqcalls, echo=FALSE}
vcf <- readVcf(file.path(VM_BASE_ANALYSIS, "SwapDetection//output_RNA_2600.vcf"), "hg19")
rnaCalls <- genotypeToSnpMatrix(vcf)$genotypes
rnaCalls <- t(matrix(as.numeric(rnaCalls), nrow=nrow(rnaCalls), ncol=ncol(rnaCalls),
                     dimnames=dimnames(rnaCalls)))
rownames(rnaCalls) <- gsub("_.*$", "", rownames(rnaCalls))
colnames(rnaCalls) <- gsub("\\.variant.*$", "", colnames(rnaCalls))
rnaCalls[rnaCalls == 0] <- NA
rnaCalls[1:5, 1:5]
```

### Extracting DNA methylation Calls ###

Extracting genotypes from methylation data is described in detail in
the other vignette.

```{r, targets, echo=FALSE, results='hide'}
samplesheets <- getView("methylationSamplesheet", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
path450k <- file.path(VM_BASE_DATA, "IlluminaHumanMethylation450k")
samplesheets$biobank_id <- gsub("-.*$", "", samplesheets$ids)
samplesheets$Basename <- with(samplesheets, file.path(path450k, "raw", Sentrix_Barcode,
                                                      paste(Sentrix_Barcode, Sentrix_Position, sep = "_")))
samplesheets <- samplesheets[!duplicated(samplesheets$run_id),]
runs <- getView("getMethylationRuns", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
runs <- runs[runs$qc == "passed",]
targets <- samplesheets[samplesheets$run_id %in% runs$run_id, ]
targets <- targets[targets$biobank_id %in% c("LL", "LLS", "NTR", "RS"),]
```

Here, we have to read in a large number of files on top of the
parallel reading we read the data in batches of 500 samples as well,
in order not to overload memory.

```{r, dnamcalls, echo=FALSE}
data(hg19.GoNLsnps)
cpgs <- unique(hg19.GoNLsnps$probe)
register(MulticoreParam(5))
maxbatch <- 500
betas <- lapply(split(targets, 1+(1:nrow(targets))%/%maxbatch), function(targetsbatch) {
            RGset <- read.metharray.exp.par(targetsbatch, verbose=FALSE)
            beta <- getBeta(RGset)
            rbind(beta[rownames(beta) %in% cpgs, ], getSnpBeta(RGset))
        })
betas <- do.call('cbind', betas)
dim(betas)

dnamCalls <- beta2genotype(betas)
dim(dnamCalls)
str(dnamCalls)
dnamCalls[1:5, 1:5]
```

### Running inter omics ###

```{r, dnadna, echo=FALSE}
dnaCalls <- dnaCalls + 1
data <- alleleSharing(dnaCalls)
mismatches <- inferRelations(data)
```

```{r, rnarna, echo=FALSE}
data <- alleleSharing(rnaCalls)
mismatches <- inferRelations(data)
```

```{r, dnamdnam, echo=FALSE}
data <- alleleSharing(dnamCalls)
mismatches <- inferRelations(data)
```

```{r, dnadnarelations, echo=FALSE, results='hide'}
ids <- gsub("^gonl-", "", colnames(dnaCalls))
relationsDNA <- expand.grid(idx=ids, idy=ids)
relationsDNA$relation_type <- "unrelated"
relationsDNA$relation_type[ gsub("[abc]", "", relationsDNA$idx) == gsub("[abc]", "", relationsDNA$idy) &
                         (grepl("c", relationsDNA$idx) | grepl("c", relationsDNA$idy))] <- "parentoffspring"
relationsDNA$relation_type[relationsDNA$idx == relationsDNA$idy] <- "identical"
relationsDNA <- subset(relationsDNA, relation_type != "unrelated")
table(relationsDNA$relation_type)
relationsDNA$idx <- paste0("gonl-", relationsDNA$idx)
relationsDNA$idy <- paste0("gonl-", relationsDNA$idy)
```

```{r, rnarnarelations, echo=FALSE, results='hide'}
relationsRNA <- expand.grid(idx=colnames(rnaCalls), idy=colnames(rnaCalls))
relationsRNA$relation_type <- "unrelated"
relationsRNA$relation_type[relationsRNA$idx == relationsRNA$idy] <- "identical"    
mid <- which(grepl("_", relationsRNA$idx) | grepl("_", relationsRNA$idy))
mmid <- mapply(FUN = function(x, y) any(unlist(strsplit(x, "_")) %in% unlist(strsplit(y, "_"))),
               as.character(relationsRNA$idx[mid]),
               as.character(relationsRNA$idy[mid]))
relationsRNA$relation_type[mid[which(mmid)]]  <- "identical"
relationsRNA <- subset(relationsRNA, relation_type != "unrelated")
table(relationsRNA$relation_type)
```

```{r, rnadnarelations, echo=FALSE, results='hide'}
##There is currently no easier way!
verbose <- FALSE
relations <- getView("getRelations", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=verbose)
relations <- subset(relations, !is.na(relation_type))

relx <- getView("getRNASeqRuns", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=verbose)
colnames(relx)[colnames(relx) == "run_id"] <- "idx"
relx <- relx[!duplicated(relx$idx), ]

rely <- getView("getImputations", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=TRUE)
rely <- subset(rely, !is.na(gonl_id))
colnames(rely)[colnames(rely) == "gonl_id"] <- "idy"

relx <- relx[!is.na(relx$idx),]
relx <- relx[!duplicated(relx$idx),]

rely <- rely[!is.na(rely$idy),]
rely <- rely[!duplicated(rely$idy),]

bRelsx <- merge(relations, relx[,c("ids", "idx")], by="ids") #link idx
bRelsx <- merge(bRelsx, rely[,c("ids", "idy")], by.x="relation_id", by.y="ids")[, c("idx", "idy", "relation_type")]

bRelsy <- merge(relations, rely[,c("ids", "idy")], by="ids") #link idy
bRelsy <- merge(bRelsy, relx[,c("ids", "idx")], by.x="relation_id", by.y="ids")[, c("idx", "idy", "relation_type")]

bRels <- rbind(bRelsx, bRelsy)
tRels <- merge(relx, rely, by="ids")[, c("idx", "idy")]
tRels$relation_type <- "identical"
relations <- rbind(bRels, tRels)
```



```{r, dnarna, echo=FALSE, cache=TRUE}
head(relations)
table(relations$relation_type)

relabel <- function(x) {
    x <- gsub("original|has monozygotic twin|has repeated measurements|merged|replicate|rerun", "identical", x)
    x <- gsub("has child|has parent", "parentoffspring", x)
    x <- gsub("has dizygotic twin|has sib", "sibship", x)
    as.character(x)
}

relations$relation_type <- relabel(relations$relation_type)
table(relations$relation_type)

rHash <- hashRelations(relations, idx.col="idx", idy.col="idy")

dnaCalls <- dnaCalls + 1 ##or rnaCalls <- rnaCalls-1

data <- alleleSharing(rnaCalls, dnaCalls, rHash)
mismatches <- predict(data)

```



