---
title: "Verifying sample relationships using genotypes or inferred genotypes"
shorttitle: "Verifying sample relationships"
package: "omicsPrint"
author: 
- name: "Maarten van Iterson"
  affiliation: 
  - "Department of Medical Statistics and Bioinformatics, Section Moleculair Epidemiology, Leiden University Medical Center"
  email: mviterson@gmail.com
- name: "Davy Cats"
  affiliation: 
  - "Department of Medical Statistics and Bioinformatics, Section Moleculair Epidemiology, Leiden University Medical Center"
  email: davycats.dc@gmail.com
date: "`r Sys.Date()`"
abstract: >
  Analysis of multiple omics datatypes from the same individuals is
  becoming increasingly common. For example, several data repositories
  contain genetic, transcriptomic and epigenetic (DNA methylation)
  measurements on the same individuals, e.g. TCGA, Geuvadis,
  BBMRI/BIOS, etc. We have developed a tool that can verify the sample
  relationships between and across omics types. A small number of
  misspecified samples can destroy analyses for example assuming an
  analysis on unrelated individuals whereas parent offspring relations
  exist.
output: 
  BiocStyle::html_document2:
    toc: true
    toc_float:
      collapsed: false
vignette: >
  %\VignetteIndexEntry{Verifying sample relationships using genotypes or inferred genotypes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: omicsPrint.bib
---


```{r setup, include=FALSE}
set.seed(22062017)
library(omicsPrint)
library(GEOquery)
library(SummarizedExperiment)
```

Here we illustrate the use of the package using artificially generated
data and provide an example of usage with experimental data.
A few other vignettes are available that show the use of the
package on experimental data, i.e. 450k DNA methylation, RNAsequencing
data and imputed genotypes.

# Within omics sample relationship verification #

## Create toy data ##

Here we generate a single vector with 100 randomly drawn integers from
the set; 1, 2, 3, representing 100 SNP calls from a single
individual. Three other samples are generated from this one by
randomly swapping a certain fraction of the SNPs. For example,
swapping only 5 SNPs only introduces some noise but should still
reflect the same individual. However, swapping 50% of the SNPs is
similar to the difference in genotypes between parents and
offspring. Swapping all SNPs will result in a unrelated individual.

```{r, toydata}
swap <- function(x, frac=0.05) {
    n <- length(x)
    k <- floor(n*frac)
    x1 <- sample(1:n,k)
    x2 <- sample(1:n,k) ##could be overlapping
    x[x2] <- x[x1]
    x
}
x1 <- 1 + rbinom(100, size=2, prob=1/3)
x2 <- swap(x1, 0.05) ##strongly related e.g. replicate
x3 <- swap(x1, 0.5) ##related e.g. parent off spring
x4 <- swap(x1, 1) ##unrelated
x <- cbind(x1, x2, x3, x4)
head(x)
```

## Running the `allelesharing` algorithm ##

We use Identity by State (IBS) for a set of SNPs to infer sample
relations. See @Abecasis2001, for the description of this approach
applied to genetic data. Briefly, between each sample pair the
identity by state vector is calculated, which is a measure of genetic
distance between individuals. Next the vector is summarized by its
mean and variance. A mean of 2 and variance of 0 indicates that the
samples are identical. 

```{r, alleleSharing}
library(omicsPrint)
data <- alleleSharing(x, verbose=TRUE)
data
```

By default no relations are assumed only the self-self
relations. Genotype calls can contain NA's, e.g. not measured in all
samples or bad quality. Some pruning is performed to remove really bad
cases.

The output is a `data.frame` containing all pairwise comparisons with
the mean and variance of the IBS over the set of SNPs and the reported
sample relationship, including the identifiers.

## Report mismatches and provide graphical summary ##

Since, we provided a list of known relations, assuming the majority is
correct, we can build a classifier to discover missclassified
relations. The current implementation uses linear discriminant
analysis and generates a confusion-matrix, graphically representation
of the classification boundaries and outputs the missclassified sample
pairs.

```{r, inferrelations, fig.cap = "Scatter-plot of IBS mean and variance with classification boundary. For pairwise comparison between the samples without specifying sample relationships."}
mismatches <- inferRelations(data)
mismatches
```

Indeed, there is one misclassified sample, the replicate that we
introduced. The true relationship with between `x1` and `x2` is an
identical relation. Furthermore, we see two sample pairs with mean IBS
of 1.7 and variance 0.2 which is an indication that also these pairs
share a considerable number of alleles. In such, cases we should
provide the known relations in a `data.frame` and specify the relation
types.

```{r, extendedrelations}
relations <- expand.grid(idx = colnames(x), idy= colnames(x))
relations$relation_type <- "unrelated"
relations$relation_type[relations$idx == relations$idy] <- "identical"
relations$relation_type[c(2,5)] <- "identical" ##replicate
relations$relation_type[c(3,7,9,10)] <- "parent offspring"
relations
```

Rerun the allelesharing algorithm now provided with the known
relations.

```{r, addrelations, fig.cap = "Scatter-plot of IBS mean and variance with classification boundaries. For pairwise comparison between the samples with specifying sample relationships."}
data <- alleleSharing(x, relations=relations)
data
mismatches <- inferRelations(data)
mismatches
```

Now there are no misclassified sample relations.

# Across omics sample relationship verification #

The previous example showed how to perform sample relationship
verification within an omics data type. If a second set of overlapping
SNPs is available, obtained from a different omic type, for the same
or related individuals sample relationshi verification can be run
between these two.

```{r, xyallelesharing, fig.cap = "Scatter-plot of IBS mean and variance with classification boundary. For pairwise comparison between the samples without specifying sample relationships."}
rownames(x) <- paste0("rs", 1:100)
y <- x[sample(1:100, 80),]
data <- alleleSharing(x, y)
data
mismatches <- inferRelations(data)
mismatches
```

Notice pruning is performed on both data types and automatically the
overlapping set of SNPs (80) is used, provided that the rownames
between `x` and `y` are the same (Note also this holds for providing
relations where the relation identifiers `idx` and `idy` should match
with the columnames of `x` and `y`).

```{r, addrelations2, fig.cap = "Scatter-plot of IBS mean and variance with classification boundaries. For pairwise comparison between the samples with specifying sample relationships."}
data <- alleleSharing(x, y, relations)
data
mismatches <- inferRelations(data)
mismatches
```

Again providing the known and true relationships yield no
missclassified sample relationships.

# An example using real world methylation data from a `SummarizedExperiment` #

Here we will show how you could varify sample relationships on
publicly available DNA methylation data. The dataset used here
contains pairs of monozygotic twins. We will extract the beta-value
matrix from GEO
[GSE100940](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE100940),
[paper in
press](http://www.sciencedirect.com/science/article/pii/S1875176817300872).
 
```{r clearworkspace, echo=FALSE}
rm(list=ls())
```

First we extract the data from GEO using the
[*GEOquery*](http://bioconductor.org/packages/GEOquery/)-package.
	
```{r downloaddataretry, echo=FALSE, results='hide'}
library(GEOquery)
library(SummarizedExperiment)
gset <- NULL
tryMax <- 5
tries <- 0
while(!inherits(gset,'list') | tries >= tryMax) {
    tries <- tries + 1
    gset <- tryCatch(
        getGEO("GSE100940", GSEMatrix=TRUE),
        error = function(e) {
            Sys.sleep(5)
            message('retrying')
            return(e)
        })
}
gset[[1]]
```
		
```{r downloaddata, eval=FALSE}
library(GEOquery)
library(SummarizedExperiment)
gset <- getGEO("GSE100940", GSEMatrix=TRUE)
gset[[1]]
```

Next we convert the returned object into a 
[*SummarizedExperiment*](http://bioconductor.org/packages/SummarizedExperiment/):

	
```{r geo2se}
se <- makeSummarizedExperimentFromExpressionSet(gset[[1]])
se
```

	
Sample data can be extracted from the `SummarizedExperiment`-object using the
`colData`-function and we can see which pair of twins each sample belongs to 
through the `source_name_ch1` field. Using this knowledge we can construct a 
table of expected relationships:
      
```{r makerelationships}
r <- expand.grid(idx=colnames(se), idy=colnames(se))
r$Xpair <- sapply(strsplit(as.character(colData(se)[r$idx, "source_name_ch1"]),
                           split = "_"), head, 1)
r$Ypair <- sapply(strsplit(as.character(colData(se)[r$idy, "source_name_ch1"]),
                           split = "_"), head, 1)
r$relation_type <- "unrelated"
r$relation_type[r$Xpair == r$Ypair] <- "twin"
r$relation_type[r$idx == r$idy] <- "identical"
head(r)
```

Several probes on the array contain SNPs occurring frequently in different 
populations[@Chen2013; @Zhou2016]. We can use these to verify the expected 
relationships. We have made these data available from inside of this package.

Now we make a selection of CpGs probably affected by polymorphic SNPS
in populations from East Asian, as these samples are from South Korea:

```{r selectcpgs}
data(hm450.manifest.pop.GoNL)
cpgs <- names(hm450.manifest.pop.GoNL[
    mcols(hm450.manifest.pop.GoNL)$MASK.snp5.EAS])
se <- se[cpgs,]
```

Next the beta-values are converted to genotypes using our enhanced
K-means algorithm:

```{r genotyping}
dnamCalls <- beta2genotype(se, assayName = "exprs")
dim(dnamCalls)
dnamCalls[1:5, 1:5]
```

The DNA methylation based genotype calls can be directly supplied to the
allelesharing algorithm to perform the intra-omic sample matching:

```{r allelesharing, fig.cap="Scatter-plot of IBS mean and variance with classification boundaries. For pairwise comparison between samples consiting of pairs of monozygotic twins."}
data <- alleleSharing(dnamCalls, relations = r, verbose = TRUE)
mismatches <- inferRelations(data)
mismatches
```

The twins are predicted as being identical to each other. This is not
unexpected as they are monozygotic.

# SessionInfo #

```{r, sessioninfo}
sessionInfo()
```

# Reference #
