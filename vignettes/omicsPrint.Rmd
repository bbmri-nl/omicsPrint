---
title: "Sample relationship verification using 450k DNA Methylation data"
author: "Maarten van Iterson"
date: "`r Sys.Date()`"
output:
  md_document:
    variant: markdown_github
vignette: >
  %\VignetteIndexEntry{omicsPrint}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette shows how `omicsPrint` can be used to verify sample
relationships using 450k DNA methylation data[@Bibikova2011]. In order
to run the verification access to the raw idat-files is required as
well as an overview of the reported sample relations. It is important
to note that all the array should pass quality control, e.g. using
[MethylAid](http://bioconductor.org/packages/MethylAid/), since
bad-quality array could introduce spurious sample relations. 

> If only beta-values are available for the signal probes,
> i.e. missing the rs-probes, probes containing SNPs should be
> extracted and if informative enough these could be used!

The following steps are involved:

1. Construct a targets-file containing path to the raw idat-files
2. Construct `data.frame` containing reported relations
3. Extract informative SNPs from 450k DNA methylation data
4. Convert beta-values to genotypes
5. Perform the sample matching across all pairs
6. Report mismatches and provide graphical summary

## Construct targets and relations ##

This part is specific to each data sets.

```{r, prepare, echo=FALSE, cache=TRUE}
suppressPackageStartupMessages({
require(BBMRIomics)
require(omicsPrint)
require(DNAmArray)
require(BiocParallel)  
})
##create targets file for LLS
samplesheets <- getView("methylationSamplesheet", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
path450k <- file.path(VM_BASE_DATA, "IlluminaHumanMethylation450k")
samplesheets$biobank_id <- gsub("-.*$", "", samplesheets$ids)
samplesheets$Basename <- with(samplesheets, file.path(path450k, "raw", Sentrix_Barcode,
                                                        paste(Sentrix_Barcode, Sentrix_Position, sep = "_")))
samplesheets <- samplesheets[!duplicated(samplesheets$run_id),]
runs <- getView("getMethylationRuns", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
runs <- runs[runs$qc == "passed",]    
targets <- samplesheets[samplesheets$run_id %in% runs$run_id, ]
targets <- targets[targets$biobank_id == "LLS",]
##create data.frame with relations
relations <- getView("getRelations", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
relations <- subset(relations, !is.na(relation_type))
relx <- getView("getMethylationRuns", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB, verbose=FALSE)
colnames(relx)[colnames(relx) == "run_id"] <- "idx"
relx <- relx[!is.na(relx$idx),]
relx <- relx[!duplicated(relx$idx),]
relations <- merge(relations, relx[,c("ids", "idx")], by="ids") #link idx
relations <- relations[!is.na(relations$idx),]
##obtain reported relations
bRels <- merge(relations, relx[, c("ids", "idx")], by.x="relation_id", by.y="ids")[,c("idx.x", "idx.y", "relation_type")]
##obtain technical relations
tRels <- merge(relx, relx, by="ids")[, c("idx.x", "idx.y")]
tRels$relation_type <- "identical"
relations <- rbind(bRels, tRels)    
```

In the end you should have a `data.frame` called targets and relations
like these:

```{r, targets, cache=TRUE}
head(targets)
```

Occasionally, it is recommended to relabel some relations, for example
using 'gsub':

```{r, relations, cache=TRUE}
head(relations)
table(relations$relation_type)
relations$relation_type <- gsub("2nd degree family", "unrelated", relations$relation_type)
relations$relation_type <- gsub("has repeated measurements|has monozygotic twin", "unrelated", relations$relation_type)
relations$relation_type <- gsub("inferred 1st degree family|has parent|has child", "parentoffspring", relations$relation_type)
relations$relation_type <- gsub("has dizygotic twin|has sib", "sibship", relations$relation_type)
table(relations$relation_type)
```

## Extract informative SNPs from 450k DNA methylation data ##

The 65 SNPs available on the array are not enough to perform sample
verification with high confidence. Fortunately, several probes on the
array contain SNPs occuring frequently in different
populations[@chen2013, @Zhou2016]. We have extended the results of
Zhou *et al.* using information from the dutch population
[GoNL](http://www.nlgenome.nl/). 


```{r, betas, cache=TRUE} 
library(DNAmArray)
data(hg19.GoNLsnps)
cpgs <- unique(hg19.GoNLsnps$probe)
library(BiocParallel)
register(MulticoreParam(10))
RGset <- read.metharray.exp.par(targets, verbose=FALSE)
betas <- getBeta(RGset)
betas <- rbind(betas[rownames(betas) %in% cpgs,], getSnpBeta(RGset))
dim(betas)
```

Here, we extract all Illumina probe identifiers that have a GoNL SNP
in there probe-sequence (see for more detail ?hg19.GoNLsnps) and the
65 SNPs provided by Illumina. Furthermore, we have used the
[DNAmArray](https://github.com/molepi/DNAmArray)
`read.metharray.exp.par`-function to read in all idat files in
parallel. 

## Convert beta-values to genotypes ##

Now we can convert the beta-values to genotypes (1, 2, 3). We have
implemented a K-means clustering approach similar to the one proposed
in the
[wateRmelon](http://bioconductor.org/packages/wateRmelon/)-package. However,
we have added some additional steps to ensure the cluster detected
have a good separation and contain sufficient number of samples.

```{r, betas2genotypes, cache=TRUE}
xCalls <- beta2genotype(betas)
xCalls[1:5, 1:5]
```

To get an idea of how the K-means clustering algorithm works a plot of
the raw beta-values of a CpG affected by a SNP can be generated like
this:

```{r, clusters, cache=TRUE}
hist(betas[rownames(betas) == rownames(xCalls)[1],], n=100, xlab="beta-values", main="CpG affect by a SNP")
rug(betas[rownames(betas) == rownames(xCalls)[1],])
```

## Perform the sample matching across all pairs ##

We use Identity by State (IBS) for a set of SNPs to infer sample
relations[@Abecasis2001].

```{r, allelesharing, cache=TRUE}
data <- alleleSharing(x=xCalls, y=NULL, relations=relations, idx.col="idx.x", idy.col="idx.y", verbose=TRUE)
head(data)
```

The output is a `data.frame` containing all pairwise comparisons with
the mean and variance of the IBS over the set of SNPs and the reported
and predicted sample relationship, including the identifiers.

## Report mismatches and provide graphical summary ##

Since, we provided a list of known relations, assuming the majority is
correct, we can build a classifier to discover missclassified
relations. The current implementation uses linear discriminant
analysis and generates a confusion-matrix, graphically representation
of the classification boundary and outputs the missclassified sample
pairs.

```{r, inferrelations, cache=TRUE}
mismatches <- inferRelations(data)
```

# SessionInfo #

```{r}
sessionInfo()
```

# Reference # 
